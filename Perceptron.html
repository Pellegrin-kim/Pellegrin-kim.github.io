<!DOCTYPE html>
<html>

<head>
    <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
<style>
#introduction {
  position: relative;
  width: 950px;
  margin-bottom = 40px;

}
#introduction h4 {
  margin-top:1em;
  margin-bottom: 0.5em;
  font-family: 'Architects Daughter', 'Helvetica Neue', Helvetica, Arial, serif;
  font-size: 15px;
  font-weight: bold;
  color: #474747;
  text-indent: 3px;
}
#introduction p {
  margin-top:0.5em;
  margin-bottom: 0.5em;
  margin-left: 4px;
  font-family: 'Architects Daughter', 'Helvetica Neue', Helvetica, Arial, serif;
  font-size: 13px;
  color: Black;
  text-align: justify;
  line-height:18px;
}
#zone1 {
  position: relative;
  width: 900px;
  height: 100px;
}
#lancement {
  position: relative;
  width: 950px;
  margin-top= 40px;
  margin-bottom = 10px;
}
#lancement h4 {
  margin-top:1em;
  margin-bottom: 0.5em;
  font-family: 'Architects Daughter', 'Helvetica Neue', Helvetica, Arial, serif;
  font-size: 15px;
  font-weight: bold;
  color: #474747;
  text-indent: 3px;
}
#lancement p {
  margin-top:0.5em;
  margin-bottom: 0.5em;
  margin-left: 4px;
  font-family: 'Architects Daughter', 'Helvetica Neue', Helvetica, Arial, serif;
  font-size: 13px;
  color: Black;
  text-align: justify;
  line-height:15px;
}
path { 
	stroke: blue;
	stroke-width: 1;
	fill: none;
}
.axis path,
.axis line {
	fill: none;
	stroke: black;
	stroke-width: 1;
	shape-rendering: crispEdges;
}
.axis text {
    font-family: sans-serif;
    font-size: 11px;
}

#zone1 {
  position: relative;
  width: 900px;
  height: 60px;
}
#zone1 h4 {
  margin-top:1em;
  margin-bottom: 0.5em;
  font-family: 'Architects Daughter', 'Helvetica Neue', Helvetica, Arial, serif;
  font-size: 15px;
  font-weight: bold;
  color: #474747;
  text-indent: 3px;
}
#zone1 p {
  margin-top:0.5em;
  margin-bottom: 0.5em;
  margin-left: 4px;
  font-family: 'Architects Daughter', 'Helvetica Neue', Helvetica, Arial, serif;
  font-size: 13px;
  color: Black;
  text-align: justify;
  line-height:15px;
}
#zone12 {
  position: relative;
  width: 900px;
  height: 30px;
}
#zone12 h4 {
  margin-top:1em;
  margin-bottom: 0.5em;
  font-family: 'Architects Daughter', 'Helvetica Neue', Helvetica, Arial, serif;
  font-size: 15px;
  font-weight: bold;
  color: #474747;
  text-indent: 3px;
}
#zone12 p {
  margin-top:0.5em;
  margin-bottom: 0.5em;
  margin-left: 4px;
  font-family: 'Architects Daughter', 'Helvetica Neue', Helvetica, Arial, serif;
  font-size: 13px;
  color: Black;
  text-align: justify;
  line-height:15px;
}
#zone13 {
  position: relative;
  width: 900px;
  height: 30px;
}
#viz {
  position: relative;
  margin-top = 20px;
  width: 1160px;
  height: 420px;
}
#zone2 {
  position: relative;
  width: 900px;
}

svg12 path{
  stroke: #000;
  stroke-width: 1px;
  stroke: rgba(0,0,0,0.2);
} 
svg12{
  background-color: Plum;
  opacity: 1;
  width: 900px;
  height: 20px;
} 
svg path{
  stroke: lightblue;
  stroke-width: 1px;
}
  
#zone2 h4 {
  margin-top:1em;
  margin-bottom: 0.5em;
  font-family: 'Architects Daughter', 'Helvetica Neue', Helvetica, Arial, serif;
  font-size: 15px;
  font-weight: bold;
  color: #474747;
  text-indent: 3px;
}
#zone2 p {
  margin-top:0.5em;
  margin-bottom: 0.5em;
  margin-left: 4px;
  font-family: 'Architects Daughter', 'Helvetica Neue', Helvetica, Arial, serif;
  font-size: 13px;
  color: Black;
  text-align: justify;
  line-height:15px;
}
  
</style>

</head>
<div id="introduction"></div>
<div id="lancement"></div>
<div id="zone1">	
	<div id="zone12"></div>
	<div id="zone13"></div>
</div>
<div id="viz"></div>
<div id="zone2"></div>
<body>

   <script charset ="utf-8" type="text/javascript">
	
	var svg0 = d3.select("#introduction").append("svg0")
    .attr("width", 900)
    .attr("height", 60)
	.style("border", 1)
	.attr("class", "graph-svg-component");
	   
	var svg1 = d3.select("#zone12").append("svg1")
    .attr("width", 500)
    .attr("height", 40)
	.style("border", 1)
	.attr("class", "graph-svg-component");
	
	var svg12 = d3.select("#zone13").append("svg12")
    .attr("width", 1160)
    .attr("height", 30)
	.style("border", 1)
	.attr("class", "graph-svg-component");
	
	var svg = d3.select("#viz").append("svg")
    .attr("width", 1050)
    .attr("height", 400)
	.style("border", 1)
	.attr("class", "graph-svg-component");
	   
	var svg2 = d3.select("#lancement").append("svg2")
    .attr("width", 900)
    .attr("height", 650)
	.style("border", 1)
	.attr("class", "graph-svg-component");
	

	

   	var numPoints = 50; // select 100 points
	var bubbleChart = [];	
	var Yn = [];
	var Xn = Create2DArray(numPoints);
	var P = [];		
	var slope = 0;
	var	lineoffset = 0;
	var Etat_droite = "Choix_en_cours";
	var Etat_points = "Choix_en_cours";
	var valide = "valide";
	var test = 0;
	var Ok_pour_perceptron = "KO";
	var W = [[]];
	W[0] =  [0,0,0,0];
	var slopeW = 0;
	var	lineoffsetW = 0;
	W[0] =  [0, 0, 0,0];
	var	IT = 0;
	var	Xb = 0;
	var	Yb = 0;
	var Ynbad = 0;
	var	Yn_w = [];
	var	Wcost = 0;
	var Wcostmin = 1000;
	var TabWcostmin = [];
	var tabl1=[];
	var paddingy = 27;
	var paddingx = 27;
	var hx = 300;
	var hy = 300;
	var Decalage_right_courbeCout = 550;
	var formatAsPercentage = d3.format(".1%");
	var w = 300;
	var Costdataset = [];
	var MaxIT = 200;


	function affichage_cout(){
		
		//ici initialiser les variables pour afficher données et axes
		Costdataset = [];
		d3.selectAll("g").remove();
			
		for (var i = 0; i < W.length; i++) { 
			Costdataset.push([W[i][3]*200,i]);// la valeur du cout est multiplie par 200 car elle correspondra ) l'affichage à un nombre de pixels qui doit être une quantité visible, l'echelle verticale est de 0 à 80%
			//d3.select("svg2").append("p").text("Costdataset[0] = "+Costdataset[i][0]+"Costdataset[1] = "+i);
		}
				
		var xScale = d3.scale.linear()
				.domain([0, d3.max(Costdataset, function(d) { return (d[1]); })])
				.range([0, d3.max(Costdataset, function(d) { return (d[1])*1.5; })]);

		var yScale = d3.scale.linear()
				.domain([0, 0.8])
				.range([hy - paddingy, paddingy]);
				
		var xAxis = d3.svg.axis()
                .scale(xScale)
                .orient("bottom")
				.ticks(3);
				  
		var yAxis = d3.svg.axis()
                .scale(yScale)
                .orient("left")
				.tickFormat(formatAsPercentage);
				  
		svg.append("g")
				.attr("class", "axis")  // Assigne la classe "axis"
				.attr("transform", "translate("+Decalage_right_courbeCout + "," + (hx - paddingx) + ")")
				.call(xAxis);
				
		svg.append("text")      // text label for the x axis
			.attr("x", Decalage_right_courbeCout + 50 )
			.attr("y", hx+15 )
			//.style("text-anchor", "middle")
			.text("Itérations");
					
		svg.append("g")
			.attr("class", "axis")
			.attr("transform", "translate("+ Decalage_right_courbeCout + ",0)")
			.call(yAxis);
				
		svg.append("text")
			.attr("transform", "rotate(-90)")
			.attr("y",Decalage_right_courbeCout - (3*paddingx))
			.attr("x",0- hx/2-paddingy)
			.attr("dy", "1em")
			.text("Taux d'erreur");
				
 				  
		var lineFunction = d3.svg.line()
                          .x(function(d) { return (d[1]); })
                          .y(function(d) { return (hx-paddingx-d[0]); })
                          .interpolate("linear");		  
		
		svg.append("path")
			.attr("id", "costpath")
			.attr("d", lineFunction(Costdataset))
			.attr("transform", "translate("+ Decalage_right_courbeCout + ",0)")
            .attr("stroke", "lightblue")
			.attr("opacity", 5)
            .attr("stroke-width", 2)
            .attr("fill", "none");		  
			
		d3.select("svg").append("text").attr("fill", "red").attr("id","p5").text("Taux d'erreur minimum: ").attr("font-size", "15px").attr("transform", "translate("+ (Decalage_right_courbeCout+150) + ","+(hx +100)+")");

			
	}
	
	function Perceptron_Pasapas() {		
		if (IT == 0){d3.select("#btn_perpOS").remove();} //on supprime le bouton de choix Perceptron One Shot
		
		drawperceptronline("svg",W,"darkgreen", 0.5);
		//d3.select("svg2").append("p").text( "Pour IT = " +IT+ "  " +"les coordonnees de W sont  "+W[IT][0] + "    "+W[IT][1] + "  "+W[IT][2]);		
		//for (var i = 0; i < numPoints; i++) {d3.select("svg2").append("p").text( "les labels des points sont "+Xn[i][2]);}
		LabelisePoints();
		Wcost = CalculateAddnewCost(Yn_w);
		affichage_cout();
		if(Wcost == 0){
			d3.select("svg0").append("button")
				.attr("id","btn0")
				.attr("value","PLAY")
				.attr("margin-top","40px")
				.text("Lancer le Perceptron")
				.on("click", Lancer_Perceptron);
			
			var slope_finale = -W[IT][1]/W[IT][2];
			var lineOffsetfinal = -W[IT][0]/W[IT][2];
			slope_finale = slope_finale.toFixed(2);
			lineOffsetfinal = lineOffsetfinal.toFixed(2);
			drawperceptronline("svg",W,"orange",4, 5);
			d3.select("svg2").append("p").text( "Le perceptron a trouvé une solution pour classer les points. ").style("color","red");
			d3.select("#btn_perpIT").remove();	
			d3.select("svg12").append("p").text("Fin de l'apprentissage - La droite identifiée est en orange sur le graphique").style("color","red");	
			d3.select("#p2").remove(); //Suppression paragraphe - Phase apprentissage
			}
			
		//d3.select("svg2").append("p").text( "Yn_w calculé " +Yn_w);
		tabl1 = FindBadPoint(Yn_w);
		//d3.select("svg2").append("p").text( "test Xb " +Xb+ "  " +"test Yb "+Yb);	
		Xb = tabl1[0];
		Yb = tabl1[1];
		Ynbad = tabl1[2];
		BadPointShow(Xb,Yb);
		CalculateAddnewW(Xb,Yb,Ynbad);
		Yn_w = [];
		IT = IT + 1;
	}
	
	function Wo_init(){
		index = getRandomInt(1, Xn.length) -1;
		W[0][0] = 20000;		
		W[0][1] = Xn[index][0] *  Xn[index][2];		
		W[0][2] = Xn[index][1] *  Xn[index][2];	
	}
	
	function LabelisePoints(){	
		for (var i = 0; i < numPoints; i++) {Yn_w[i]  = Math.sign((W[IT][0]*1+(W[IT][1]*(Xn[i][0]-200))+(W[IT][2]*(Xn[i][1]-200))));
			//on pose Xo egal à 1,les -200 correspondent au changement de reperes, les calcul sont dans le repère dont 0 est l'origine, au milieu du carré. sur le graphique le carré a pour origine sont coin en haut à gauche
		}		
	}
	
	function CalculateAddnewCost(Yn_w){	
		Wcost = 0;
		for (var i = 0; i < numPoints; i++) {
			if ((Yn_w[i] * Xn[i][2]) < 0){Wcost = Wcost + 1;} 
		}
		Wcost = Wcost / numPoints;
		W[IT][3] = Wcost;
		//d3.select("svg2").append("p").text("Pour IT = " + IT + " Le taux d'erreur est: " +Wcost);	
		
		if (Wcost < Wcostmin){		
			Wcostmin = Wcost;
			TabWcostmin = [W[IT][0],W[IT][1],W[IT][2]];
			d3.select("#p5").text("Taux d'erreur minimum: " + Wcostmin );
		}
		
		
		return Wcost;
	}
	
	function FindBadPoint(Yn_w){
		var BadPoint = [];
		var Xbad = 0;
		var Ybad = 0;
		var Ynbad = 0;
		var tabl=[];
		for (var i = 0; i < numPoints; i++) {
			if ((Yn_w[i] * Xn[i][2])<0){
				BadPoint.push([i]);
				test = 22;
			}
		}		
		index = getRandomInt(1, BadPoint.length) -1;
		Xbad = Xn[BadPoint[index]][0];
		Ybad = Xn[BadPoint[index]][1];
		Ynbad = Xn[BadPoint[index]][2];
		
		//d3.select("svg2").append("p").text("Pour IT = " + IT +" "+ "Nombre de points mal classes =  " +BadPoint.length +" l'index d'un point retenu est "+index + " avec: X = "+Xbad +"Y = "+Ybad);	
		tabl[0] = Xbad;
		tabl[1] = Ybad;
		tabl[2] = Ynbad;
		return tabl;
	}
	
	function BadPointShow(Xb,Yb){	
		d3.select("#Badpointcircle").remove();		
		
		//cette façon de faire efface un point il faut faire un append avec les coordonnées CoordXY
		d3.select("svg").append("circle").attr("id", "Badpointcircle")    
			.style("stroke", "black")
			.style("stroke-width", 1)
			.style("fill", "none")		
			.attr("r", 8)
			.attr("cx", Xb)
			.attr("cy", Yb);
	}
	
	function CalculateAddnewW(Xb,Yb,Ynbad){
		var W0 = W[IT][0] + (400* Ynbad);	// pour adaptation aux coordonnées non normalisées des points et graphique de 500 par 500	
		var W1 = W[IT][1] + ((Xb-200) * Ynbad);		
		var W2 = W[IT][2] + ((Yb-200) * Ynbad);
		//d3.select("svg2").append("p").text( "Ynbad du badpoint: "+Ynbad);		
		//d3.select("svg2").append("p").text( "Les anciennes coord de W sont: Wo = " +W[IT][0]+ "  " +"W1 =  "+W[IT][1]+"W2 =  "+W[IT][2]);	
		//d3.select("svg2").append("p").text( "Les nouvelles coord de W sont: Wo = " +W0+ "  " +"W1 =  "+W1+"W2 =  "+W2);	
		W.push([W0,W1,W2,0]);
	}
	
	function Perceptron_Oneshot() {				
		d3.select("#btn_perpIT").remove();		
		
		for(var i=0;i<MaxIT;i++){
			IT = i;
			drawperceptronline("svg",W,"darkgreen", 0.5);
			LabelisePoints();
			Wcost = CalculateAddnewCost(Yn_w);
			affichage_cout();
			if(Wcost == 0){
				d3.select("svg0").append("button")
					.attr("id","btn0")
					.attr("value","PLAY")
					.text("Lancer le Perceptron")
					.on("click", Lancer_Perceptron);			
				var slope_finale = -W[IT][1]/W[IT][2];
				var lineOffsetfinal = -W[IT][0]/W[IT][2];
				slope_finale = slope_finale.toFixed(2);
				lineOffsetfinal = lineOffsetfinal.toFixed(2);
				drawperceptronline("svg",W,"orange",4, 5);
				d3.select("svg2").append("p").text( "Le perceptron a trouvé une solution pour classer les points. C'est la droite de pente "+slope_finale+" et d'offset Yo = "+ lineOffsetfinal).style("color","red");
				d3.select("svg12").append("p").text("Fin de l'apprentissage - La droite identifiée est en orange sur le graphique").style("color","red");	
				d3.select("#p2").remove(); //Suppression paragraphe - Phase apprentissage
				d3.select("#btn_perpOS").remove();
			}
				
			tabl1 = FindBadPoint(Yn_w);		
			Xb = tabl1[0];
			Yb = tabl1[1];
			Ynbad = tabl1[2];
			CalculateAddnewW(Xb,Yb,Ynbad);
			Yn_w = [];
			if(IT == MaxIT-1){				
				d3.select("svg2").append("p").text( "Le perceptron a effectué 200 itérations , la meilleure solution est la droite affichée en orange , elle est associée à un taux d'erreur de: "+Wcostmin);
				d3.select("#p2").remove(); //Suppression paragraphe - Phase apprentissage
				//d3.select("svg2").append("p").text("la valeut de TabWcostmin[0][1]  est:  "+ TabWcostmin[0][1] +" et celle de est W[IT_int][2]"+ W_int[IT_int][2]);	
				drawperceptronline_finalErrorRate("svg",TabWcostmin,"orange",4, 5); // il faut ajouter un argument dans cette fonction pour le cas ou le W choisi n'est identifiable par l'IT en cours comme ici où on revient dans le passé
				d3.select("svg0").append("button")
					.attr("id","btn0")
					.attr("value","PLAY")
					.text("Lancer le Perceptron")
					.on("click", Lancer_Perceptron);	
				d3.select("#btn_perpOS").remove();
			}
		
		}
	}
	function drawperceptronline_finalErrorRate(svg,TabWcostmin,linecolor,strokewidth, opacity){		
		//d3.select("svg2").append("p").text("la valeut de TabWcostmin[1]  est:  "+ TabWcostmin[1] +" et celle de estTabWcostmin[2]"+ TabWcostmin[2]);		
		slopeW = -1*(TabWcostmin[1]/TabWcostmin[2]); 
		lineoffsetW = -1*(TabWcostmin[0]/TabWcostmin[2]); 
		//W et x y sont ici exprimes dans un repère centré sur l'origine
		var x1 = -200;
		var y1 = x1*slopeW + lineoffsetW;
		var x2 = 200 ;
		var y2 = x2*slopeW + lineoffsetW;
		
		// Attention: changement de repère pour l'affichage
		d3.select(svg)
			.append('line')
			.attr({ x1:x1+200, y1:y1+200, x2: x2+200, y2: y2+200 })
			.attr("opacity", opacity)
			.style("stroke", linecolor)
			.style("stroke-width", strokewidth);
		//d3.select("svg2").append("p").text("La pente de la droite trouvee par le perceptron est   "+ slopeW +" la valeur d'offset Yo est "+ lineoffsetW);				
		//d3.select("svg2").append("p").text("Les points dans repere d'affichage de la droite trouvee    "+ x1+250 +" "+ y1+250 +"        "+ x2+250 + " " + y2+250);
			
	}
	
	
	function drawperceptronline(svg,W,linecolor,strokewidth, opacity){	
		
		//d3.select("svg2").append("p").text("la valeut de IT_int est:  "+ IT_int);		
		//d3.select("svg2").append("p").text("la valeut de W[IT_int][1]  est:  "+ W_int[IT_int][1] +" et celle de est W[IT_int][2]"+ W_int[IT_int][2]);		
		slopeW = -1*(W[IT][1]/W[IT][2]); 
		lineoffsetW = -1*(W[IT][0]/W[IT][2]); 
		//W et x y sont ici exprimes dans un repère centré sur l'origine
		var x1 = -200;
		var y1 = x1*slopeW + lineoffsetW;
		var x2 = 200 ;
		var y2 = x2*slopeW + lineoffsetW;
		
		// Attention: changement de repère pour l'affichage
		d3.select(svg)
			.append('line')
			.attr({ x1:x1+200, y1:y1+200, x2: x2+200, y2: y2+200 })
			.attr("opacity", opacity)
			.style("stroke", linecolor)
			.style("stroke-width", strokewidth);
		//d3.select("svg2").append("p").text("La pente de la droite trouvee par le perceptron est   "+ slopeW +" la valeur d'offset Yo est "+ lineoffsetW);				
		//d3.select("svg2").append("p").text("Les points dans repere d'affichage de la droite trouvee    "+ x1+250 +" "+ y1+250 +"        "+ x2+250 + " " + y2+250);	
	}
	
	function Create2DArray(rows) {
		var arr = [];

		for (var i=0;i<rows;i++) {
			arr[i] = [];
		}

		return arr;
	}
	function Etiquetage() {
            
			for (var i = 0; i < numPoints; i++) {
				Xn[i][0] = bubbleChart[i][0];
				Xn[i][1] = bubbleChart[i][1];
				Xn[i][2] = Math.sign( Xn[i][1] - slope*Xn[i][0] - lineoffset) // On assigne a chaque point la valeur +1 si pour ce point y-aX-b >=0 et on assigne -1 si cette valeur est <0					
			}
			
			var tb2 = d3.selectAll("circle").data(Xn); // selection des cercles et lien avec le tableau de valeurs Xn
			tb2.style("stroke", "black");
			tb2.style("stroke-width", 1);
			tb2.style("opacity",0.5);
			tb2.style("fill", function(d) { 
									if (d[2] >= 0){return "red";}
									else{return "deepskyblue";}
									
								});
			tb2.attr("r", 3);
			tb2.attr("cx", function(d) { return d[0]; });
			tb2.attr("cy", function(d) { return d[1]; });
			
			d3.select("svg2").append("p").text("Les points forment deux groupes différents, les bleus (Label = -1) et les rouges (Label = +1))");	
			d3.selectAll("#btn3").remove();				
			//d3.select("#btn3").remove(); //suppression du bouton d'etiquetage des points
			Ok_pour_perceptron = "OK";
			Wo_init();
			d3.select("#p1").remove();	//suppression du texte "Preparation du jeu de donneés"
			d3.select("svg2").append("h4").attr("id","p6").text("Phase d'apprentissage").style("font-size", "17px");	
			if(Ok_pour_perceptron == "OK"){
				d3.select("#p1").remove();
				//d3.select("svg1").append("p").attr("id","p2").text("Phase d'apprentissage").style("font-size", "17px");					
				d3.select("svg2").append("p").text( "A chaque itération le perceptron calcule une nouvelle droite (affichée en vert), il calcule ensuite le taux d'erreur obtenu avec cette nouvelle droite. Le taux d'erreur correspond au rapport du nombre de points mal classés sur l'ensemble des points.");
				d3.select("svg2").append("p").text( "Le perceptron choisit ensuite un point au hasard parmi les points qu'il a mal classés, ce point lui sert à s'orienter pour calculer d'une nouvelle droite. Si vous choisissez l'exécution pas à pas, ce point est identifiable sur le graphique, il est entouré d'un cercle gris. On observe aussi à l'exécution pas à pas que les points choisis par le Perceptron sont toujours soit des points rouges au dessus de la droite verte soit des points bleus en dessous de la droite verte.");
				d3.select("svg2").append("p").text( "Si a répartition des points est trop dispropotionnée (Ex: seulement deux points bleus pour 48 points rouges), il se peut que le perceptron ne converge pas vers une solution à taux d'erreur nul mais oscille indéfiniment. On considèrera alors comme solution une droite pour laquelle le taux d'erreur est minimum.");
				d3.select("svg2").append("p").text( "L'option -One Shot- lance l'apprentissage sans arrêt à chaque itération.");

				
				d3.select("svg12").append("button")
					.attr("id","btn_perpIT")
					.attr("value","Perceptron pas a pas")
					.text("Perceptron pas a pas");
					
				d3.select("#btn_perpIT")
					.on("click",function() {
						if(this.value == "Perceptron pas a pas") {
							this.value = "Clicker pour itérer";
							d3.select(this).text("Clicker pour itérer");
							Perceptron_Pasapas();
						}
						else {
							Perceptron_Pasapas();
						}		
					});
				
				d3.select("svg12").append("button")
					.attr("id","btn_perpOS")
					.attr("value","Perceptron One Shot")
					.on("click", Perceptron_Oneshot)
					.text("Perceptron One Shot");	

				
				}
        }
	function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
	function validation_droite() {
			d3.select("svg12").append("button")
			.text("Valider la séparation")
			.attr("id","btn12")
			.on("click", removebutton_bnt1);	
			
		}
	function validation_point() {
			d3.select("svg12").append("button")
			.text("Valider les points")
			.attr("id","btn22")
			.on("click", removebutton_bnt2);
		}
	function removebutton_bnt1() {
			d3.select("#btn1").remove();//on supprime le bouton change de droite
			d3.select(this).remove();//on supprime le bouton de validation de la droite
			d3.select("svg2").append("p").text("La droite choisie permettra de séparer les points en deux groupes.");	
			Etat_droite = "valide";	
			if(Etat_droite == "valide"){	
				if(Etat_points == "valide"){
					d3.select("svg1").append("button")
						.attr("id","btn3")
						.on("click", Etiquetage)
						.text("Lancer l'étiquetage des points");
				}	
			}				
		}
	function removebutton_bnt2() {
			d3.select("#btn2").remove();//on supprime le bouton change de points
			d3.select(this).remove();//on supprime le bouton de validation de points
			d3.select("svg2").append("p").text( "Les "+numPoints +" points choisis pour représenter les données vont servir à l'apprentissage du Perceptron.");	
			Etat_points = "valide";
				
			if(Etat_droite == "valide"){	
				if(Etat_points == "valide"){
					d3.select("svg1").append("button")
						.attr("id","btn3")
						.on("click", Etiquetage)
						.text("Lancer l'étiquetage des points");
				}	
			}
		}	
	var runCircles = function() {
		d3.selectAll("circle").remove();
		bubbleChart = [];
		for (var i = 0; i < numPoints; i++) {
			bubbleChart.push([Math.floor(Math.random() * 400), Math.floor( Math.random() * 400)]);
		}	
	
		var tb = svg.selectAll("circle").data(bubbleChart);	   
		tb.enter()
			.append("circle")
			.style("stroke", "black")
			.style("fill", "black")
			.style("opacity", 0.5)
			.attr("r", 3)
			.attr("cx", function(d) { return d[0]; })
			.attr("cy", function(d) { return d[1]; });
			       
		tb.exit().remove();	 
	};
    //Draw a line
	var runLine = function() {
		d3.selectAll("path").remove();
		slope = getRandomInt(-40,+40)/10; 
		lineoffset = getRandomInt(50,250);
		var x1 = 0;
		var y1 = x1*slope + lineoffset;
		var x2 = 400;
		var y2 = x2*slope + lineoffset;

		
		//var datasetpoints = [[x1, y1, x2, y2]];
		var datasetpoints2 = [[x1,y1], [x2,y2],];
						
		svg.selectAll("path.area")
			.data([datasetpoints2])      
		.enter().append("path")
		.style("fill", "deepskyblue")
		.attr("opacity", 0.4)
		.attr("stroke", "black")
        .attr("stroke-width", 1)
		.attr("class", "area") 
		.attr("d", d3.svg.area());
	};	 
	
	function Lancer_Perceptron(){
	
		//Reinitialiser toutes les variables globales
		
		numPoints = 50; // select 100 points
		bubbleChart = [];	
		Yn = [];
		Xn = Create2DArray(numPoints);
		P = [];		
		slope = 0;
		lineoffset = 0;
		Etat_droite = "Choix_en_cours";
		Etat_points = "Choix_en_cours";
		valide = "valide";
		test = 0;
		Ok_pour_perceptron = "KO";
		W = [[]];
		W[0] =  [Math.random(), Math.random(), Math.random(),0];
		slopeW = 0;
		lineoffsetW = 0;
		W[0] =  [0, 0, 0,0];
		IT = 0;
		Xb = 0;
		Yb = 0;
		Ynbad = 0;
		Yn_w = [];
		Wcost = 0;
		Wcostmin = 1000;
		var TabWcostmin = [];
		tabl1=[];
		var paddingy = 30;
		var paddingx = 30;
		var hx = 300;
		var hy = 300;	
		var Decalage_right_courbeCout = 500;
		var formatAsPercentage = d3.format(".1%");
		var xScale = d3.scale.linear();
		var yScale = d3.scale.linear();
		var w = 500;
		Costdataset = [];
		var MaxIT = 200;
		
		
		d3.selectAll("button").remove();
		d3.selectAll("line").remove();
		d3.selectAll("circle").remove();
		d3.selectAll("path").remove();
		d3.selectAll("path.area").remove();
		d3.selectAll("p").remove();
		d3.selectAll("h4").remove();
		d3.selectAll("g").remove();
		d3.select("#costpath").remove();
		d3.select("#Badpointcircle").remove();
		d3.selectAll("text").remove();

			
		d3.selectAll("svg").append("rect")
			.style("fill", "Plum")
			.attr("opacity", 0.4)
			.attr("stroke", "black")
			.attr("stroke-width", 1)
			.attr("width", 400)
			.attr("height", 400);

		d3.select("svg1").append("button")
				.attr("id","btn1")
				.attr("value","Choisir une séparation")
				.text("Choisir une separation");
			
		d3.select("svg1").append("button")
				.attr("id","btn2")
				.attr("value","Choisir les points")
				.text("Choisir les points");
			
		d3.select("#btn1")
			.on("click",function() {
				if(this.value == "Choisir une séparation") {
					this.value = "Changer de séparation";
					d3.select(this).text("Changer de séparation");
					runLine();
					validation_droite();	
				}
				else {
					runLine();
				}		
		});
	
		d3.select("#btn2")
			.on("click",function() {
				if(this.value == "Choisir les points") {
					this.value = "Changer les points";
					d3.select(this).text("Changer les points");
					runCircles();			
					validation_point();			
				}
				else {
					runCircles();
				}
		});
		d3.select("svg2").append("h4").attr("id","p6").text("Phase de préparation des données").style("font-size", "17px");	
			
	}
		
		d3.select("svg0").append("p").text("Le Perceptron est l'algorithme le plus simple qui existe pour identifier une séparation entre deux groupes de points. C'est une brique de base de l'apprentissage automatique qui permet de créer d'autres modèles bien plus complexes comme les réseaux de neuronnes.");
		d3.select("svg0").append("p").text("Pourquoi vouloir classer des groupes de points? Il y a beaucoup de cas d'usages dans lesquels il faut pouvoir identifier une donnée inconue à partir de caractéristiques connues mais très nombreuses et difficiles à exploiter rapidement. On peut vouloir par exemple détecter qu'un mail reçu est un spam ou qu'une transaction bancaire est frauduleuse. Ce type d'algorythme peut aussi servir à classer les demandeurs de crédits en profils plus ou moins avantageux pour la banque.");
		d3.select("svg0").append("p").text("Le Perceptron demande une phase d'apprentissage avec des données acquises dont on connait le groupe d'appartenance. Lorsque le Perceptron a appris à définir une séparation entre deux groupes, il peut alors prédire le groupe d'appartenance de nouveaux points.");
		d3.select("svg0").append("p").text("L'application ci dessous permet de visualiser les étapes de mise en fonctionnement du Perceptron et de tester la capacité de prédiction en phase opérationnelle.");
		d3.select("svg0").append("p").text("Le mode pas à pas laisse la main à l'utilisateur pour déclencher une itération d'apprentissage alos que le mode -One Shot- lance automatiquement cette etape.");
		d3.select("svg0").append("p").text("A vous de jouer!");
	
	var createbutton = d3.select("#lancement").append("button")
			.attr("id","btn0")
			.attr("value","PLAY")
			.style("text-align","center")
			.text("Lancer le Perceptron")
			.on("click", Lancer_Perceptron);
			
	//ne fonctionne pas sur IE qui ne supporte pas la fonction Math.sign()
			//userAgent in IE7 WinXP returns: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; .NET CLR 2.0.50727)
			//userAgent in IE11 Win7 returns: Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko

			if (navigator.userAgent.indexOf('MSIE') != -1)
				var detectIEregexp = /MSIE (\d+\.\d+);/ //test for MSIE x.x
			else // if no "MSIE" string in userAgent
				var detectIEregexp = /Trident.*rv[ :]*(\d+\.\d+)/ //test for rv:x.x or rv x.x where Trident string exists

			if (detectIEregexp.test(navigator.userAgent)){ //if some form of IE
				d3.select("svg12").append("h4").attr("id","p1").text("You use Internet Explorer, you're in bad luck ... try a modern web browser like Chrome or Fire Fox.").style("font-size", "17px").style("color","Blue");
				d3.selectAll("button").remove();
				d3.selectAll("rect").remove();
			}
			else{
				//document.write("n/a")
			}
	

    </script>
	
</body>
</html>